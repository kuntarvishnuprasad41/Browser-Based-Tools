<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Unicode Character Inspector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configure Tailwind CSS for dark mode based on media query
        tailwind.config = {
          darkMode: 'media', // This is the default, but explicitly stating it can be good.
          theme: {
            extend: {},
          }
        }
    </script>
    <script src="_Blocks.js" defer onerror="handleBlocksJsError()"></script>
    <script src="_UnicodeData.js" defer onerror="handleUnicodeDataJsError()"></script>
    <script src="_ChartLinks.js" defer onerror="handleChartLinksJsError()"></script> 
    <script src="_EmojiData.js" defer onerror="handleEmojiDataJsError()"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        .table-cell-valign { vertical-align: middle; }
        .download-icon {
            display: inline-block;
            width: 0.8em;
            height: 0.8em;
            margin-left: 0.25em;
            vertical-align: middle;
        }
        .expandable-icon {
            cursor: pointer;
            display: inline-block;
            margin-right: 8px;
            transition: transform 0.2s ease-in-out;
            font-size: 0.8em; /* Make icon a bit smaller */
        }
        .expanded .expandable-icon {
            transform: rotate(90deg);
        }
        .sub-table-container {
            padding: 0; /* Remove padding if td has it */
        }
        .sub-table-container table {
            width: 100%;
            background-color: rgba(0,0,0,0.02); /* Slight background tint for sub-table */
        }
        .dark .sub-table-container table {
            background-color: rgba(255,255,255,0.03); /* Dark mode tint */
        }
        .sub-table-container th, .sub-table-container td {
            font-size: 0.9em; /* Slightly smaller font for sub-table */
        }
    </style>
</head>
<body class="bg-stone-100 text-stone-800 min-h-screen flex flex-col items-center py-8 px-4 dark:bg-stone-900 dark:text-stone-200">

    <div class="w-full max-w-7xl bg-white p-6 sm:p-8 rounded-xl shadow-lg dark:bg-stone-800 dark:shadow-none">
        <header class="mb-8 text-center">
            <h1 class="text-3xl sm:text-6xl font-bold text-sky-700 dark:text-sky-850">Unicode Inspector</h1>
            <p class="text-stone-600 mt-2 dark:text-stone-400">Paste your text below or use the lookup options to analyze Unicode characters and sequences.</p>
        </header>

        <div id="setupContainer" class="hidden">
            <section class="mb-6 p-4 bg-gray-100 border border-gray-300 rounded-lg dark:bg-stone-700 dark:border-stone-600">
                <h3 class="text-lg font-semibold text-gray-800 mb-2 dark:text-stone-200">One-Time Setup: Download The Latest Data From Unicode.org</h3>
                <p class="text-sm text-stone-700 mb-3 dark:text-stone-300">
                    For the most details about Unicode characters, you'll need to generate some local files using Unicode character data hosted by Unicode.org (the official site for Unicode). 
                </p>
                <ol class="list-decimal list-inside text-sm text-stone-700 space-y-1 dark:text-stone-300">
                    <li>Download each required <code>.txt</code> file from unicode.org.</li>
                    <li>Use the "Choose File" buttons to select that same downloaded <code>.txt</code> file.</li>
                    <li>Click the "Generate [Filename].js" button.</li>
                    <li>Save the generated <code>.js</code> file into the <strong>same folder</strong> as this HTML file.</li>
                    <li>Refresh this page after all are generated. From now on, the tool will automatically load the data. (You can delete the <code>.txt</code> files)</li>
                </ol>
                <p class="text-xs text-stone-500 mt-3 dark:text-stone-400">
                    If <code>.js</code> files are not found or are invalid, the tool will use built-in limited data. The setup sections below will appear if their corresponding <code>.js</code> file is missing.
                </p>
            </section>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-2">
                <section id="blocksSetupSection" class="p-4 bg-sky-50 border border-sky-200 rounded-lg hidden dark:bg-sky-900 dark:border-sky-700">
                    <h3 class="text-lg font-semibold text-sky-700 mb-2 dark:text-sky-300">_Blocks.js Setup</h3>
                    <p id="blocksSetupInstructions" class="text-xs text-stone-600 mb-1 dark:text-stone-300">Select <code>Blocks.txt</code>.</p>
                    <p class="text-xs text-stone-500 mb-2 dark:text-stone-400">(Download From: <a href="https://www.unicode.org/Public/UNIDATA/Blocks.txt" target="_blank" rel="noopener noreferrer" class="text-sky-600 hover:text-sky-800 underline dark:text-sky-300 dark:hover:text-sky-100">unicode.org/Public/UNIDATA/Blocks.txt <svg class="download-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v4a1 1 0 102 0V7zM9 9a1 1 0 000 2h2a1 1 0 100-2H9z" clip-rule="evenodd" /><path d="M4.53 4.53a.75.75 0 00-1.06 1.06l7.5 7.5a.75.75 0 001.06 0l7.5-7.5a.75.75 0 00-1.06-1.06L12 10.94l-6.47-6.47z" transform="translate(0 5)"/></svg></a>)</p>
                    <input type="file" id="blocksFileUpload" accept=".txt" class="block w-full text-sm file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:text-xs file:font-semibold file:bg-sky-100 file:text-sky-700 hover:file:bg-sky-200 cursor-pointer dark:file:bg-sky-700 dark:file:text-sky-100 dark:hover:file:bg-sky-600"/>
                    <button id="blocksGenerateButton" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-1 px-2 text-xs rounded shadow disabled:bg-stone-400 dark:disabled:bg-stone-600" disabled>Generate _Blocks.js</button>
                </section>

                <section id="unicodeDataSetupSection" class="p-4 bg-orange-50 border border-orange-200 rounded-lg hidden dark:bg-orange-900 dark:border-orange-700">
                    <h3 class="text-lg font-semibold text-orange-700 mb-2 dark:text-orange-300">_UnicodeData.js Setup</h3>
                    <p id="unicodeDataSetupInstructions" class="text-xs text-stone-600 mb-1 dark:text-stone-300">Select <code>UnicodeData.txt</code>.</p>
                    <p class="text-xs text-stone-500 mb-2 dark:text-stone-400">(Download From: <a href="https://www.unicode.org/Public/UNIDATA/UnicodeData.txt" target="_blank" rel="noopener noreferrer" class="text-orange-600 hover:text-orange-800 underline dark:text-orange-300 dark:hover:text-orange-100">unicode.org/Public/UNIDATA/UnicodeData.txt <svg class="download-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v4a1 1 0 102 0V7zM9 9a1 1 0 000 2h2a1 1 0 100-2H9z" clip-rule="evenodd" /><path d="M4.53 4.53a.75.75 0 00-1.06 1.06l7.5 7.5a.75.75 0 001.06 0l7.5-7.5a.75.75 0 00-1.06-1.06L12 10.94l-6.47-6.47z" transform="translate(0 5)"/></svg></a>)</p>
                    <input type="file" id="unicodeDataFileUpload" accept=".txt" class="block w-full text-sm file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:text-xs file:font-semibold file:bg-orange-100 file:text-orange-700 hover:file:bg-orange-200 cursor-pointer dark:file:bg-orange-700 dark:file:text-orange-100 dark:hover:file:bg-orange-600"/>
                    <button id="unicodeDataGenerateButton" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-1 px-2 text-xs rounded shadow disabled:bg-stone-400 dark:disabled:bg-stone-600" disabled>Generate _UnicodeData.js</button>
                </section>

                <section id="chartLinksSetupSection" class="p-4 bg-teal-50 border border-teal-200 rounded-lg hidden dark:bg-teal-900 dark:border-teal-700">
                    <h3 class="text-lg font-semibold text-teal-700 mb-2 dark:text-teal-300">_ChartLinks.js Setup</h3>
                    <p id="chartLinksSetupInstructions" class="text-xs text-stone-600 mb-1 dark:text-stone-300">Select <code>unversionedchartlist.txt</code>.</p>
                    <p class="text-xs text-stone-500 mb-2 dark:text-stone-400">(Download From: <a href="https://www.unicode.org/charts/PDF/unversionedchartlist.txt" target="_blank" rel="noopener noreferrer" class="text-teal-600 hover:text-teal-800 underline dark:text-teal-300 dark:hover:text-teal-100">unicode.org/charts/PDF/unversionedchartlist.txt <svg class="download-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v4a1 1 0 102 0V7zM9 9a1 1 0 000 2h2a1 1 0 100-2H9z" clip-rule="evenodd" /><path d="M4.53 4.53a.75.75 0 00-1.06 1.06l7.5 7.5a.75.75 0 001.06 0l7.5-7.5a.75.75 0 00-1.06-1.06L12 10.94l-6.47-6.47z" transform="translate(0 5)"/></svg></a>)</p>
                    <input type="file" id="chartLinksFileUpload" accept=".txt" class="block w-full text-sm file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:text-xs file:font-semibold file:bg-teal-100 file:text-teal-700 hover:file:bg-teal-200 cursor-pointer dark:file:bg-teal-700 dark:file:text-teal-100 dark:hover:file:bg-teal-600"/>
                    <button id="chartLinksGenerateButton" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-1 px-2 text-xs rounded shadow disabled:bg-stone-400 dark:disabled:bg-stone-600" disabled>Generate _ChartLinks.js</button>
                </section>

                <section id="emojiDataSetupSection" class="p-4 bg-purple-50 border border-purple-200 rounded-lg hidden dark:bg-purple-900 dark:border-purple-700">
                    <h3 class="text-lg font-semibold text-purple-700 mb-2 dark:text-purple-300">_EmojiData.js Setup</h3>
                    <p id="emojiDataSetupInstructions" class="text-xs text-stone-600 mb-1 dark:text-stone-300">Select <code>emoji-ordering.txt</code>.</p>
                    <p class="text-xs text-stone-500 mb-2 dark:text-stone-400">(Download From: <a href="https://unicode.org/emoji/charts/emoji-ordering.txt" target="_blank" rel="noopener noreferrer" class="text-purple-600 hover:text-purple-800 underline dark:text-purple-300 dark:hover:text-purple-100">unicode.org/emoji/charts/emoji-ordering.txt <svg class="download-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v4a1 1 0 102 0V7zM9 9a1 1 0 000 2h2a1 1 0 100-2H9z" clip-rule="evenodd" /><path d="M4.53 4.53a.75.75 0 00-1.06 1.06l7.5 7.5a.75.75 0 001.06 0l7.5-7.5a.75.75 0 00-1.06-1.06L12 10.94l-6.47-6.47z" transform="translate(0 5)"/></svg></a>)</p>
                    <input type="file" id="emojiDataFileUpload" accept=".txt" class="block w-full text-sm file:mr-2 file:py-1 file:px-2 file:rounded file:border-0 file:text-xs file:font-semibold file:bg-purple-100 file:text-purple-700 hover:file:bg-purple-200 cursor-pointer dark:file:bg-purple-700 dark:file:text-purple-100 dark:hover:file:bg-purple-600"/>
                    <button id="emojiDataGenerateButton" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-1 px-2 text-xs rounded shadow disabled:bg-stone-400 dark:disabled:bg-stone-600" disabled>Generate _EmojiData.js</button>
                </section>
            </div>
            <hr class="my-8 border-stone-300 dark:border-stone-600">
        </div>

        <section class="mb-8 p-4 bg-indigo-50 border border-indigo-200 rounded-lg dark:bg-slate-900 dark:border-indigo-700">
            <h3 class="text-xl font-semibold text-indigo-700 mb-4 dark:text-indigo-300">Lookup Specific Characters</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <label for="codepointInput" class="block text-sm font-medium text-stone-700 mb-1 dark:text-stone-300">By Codepoint (Hex, e.g., 0041 or U+1F600)</label>
                    <div class="flex">
                        <input type="text" id="codepointInput" class="flex-grow p-2 border border-stone-300 rounded-l-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 dark:bg-stone-700 dark:border-stone-600 dark:text-stone-100 dark:focus:ring-indigo-400 dark:focus:border-indigo-400" placeholder="e.g., U+0041">
                        <button id="lookupByCodepointButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-r-lg dark:bg-indigo-700 dark:hover:bg-indigo-600">Lookup</button>
                    </div>
                </div>
                <div>
                    <label for="nameInput" class="block text-sm font-medium text-stone-700 mb-1 dark:text-stone-300">By Name (contains, case-insensitive)</label>
                    <div class="flex">
                        <input type="text" id="nameInput" class="flex-grow p-2 border border-stone-300 rounded-l-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 dark:bg-stone-700 dark:border-stone-600 dark:text-stone-100 dark:focus:ring-indigo-400 dark:focus:border-indigo-400" placeholder="e.g., LATIN SMALL LETTER A">
                        <button id="lookupByNameButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-r-lg dark:bg-indigo-700 dark:hover:bg-indigo-600">Lookup</button>
                    </div>
                </div>
            </div>
        </section>
        
        <section class="mb-2 px-6 pb-2 bg-blue-50 border border-slate-200 rounded-lg dark:bg-gray-800 dark:border-blue-800">
            <div id="lookupMessageArea" class="text-sm text-stone-600 mb-3 p-2 bg-stone-50 rounded-lg border border-stone-200 hidden dark:bg-stone-700 dark:border-stone-600 dark:text-stone-300"></div>
            <label for="textInput" class="block text-2xl mt-4 mb-4 font-semibold text-stone-700 dark:text-stone-200">Input Text:</label>
            <textarea id="textInput" rows="8" class="w-full p-3 border border-stone-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500 transition-colors dark:bg-stone-700 dark:border-stone-600 dark:text-stone-100 dark:focus:ring-sky-400 dark:focus:border-sky-400" placeholder="Paste text here... e.g., Hello World! ðŸ‘‹ â‚¬ Î± ðŸ‘"></textarea>
            
            <div class="flex flex-col sm:flex-row items-center justify-start mt-4 mb-4">
                <button id="analyzeButton" class="w-full sm:w-auto bg-sky-600 hover:bg-sky-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-150 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50 dark:bg-sky-700 dark:hover:bg-sky-600 dark:focus:ring-sky-400 mb-3 sm:mb-0 sm:mr-6">Analyze Text</button>
                <div class="flex items-center">
                    <input type="checkbox" id="sequentialModeCheckbox" class="mr-2 h-4 w-4 text-sky-600 border-stone-300 rounded focus:ring-sky-500 dark:focus:ring-sky-400 dark:text-sky-700 dark:border-stone-600 dark:bg-stone-700">
                    <label for="sequentialModeCheckbox" class="text-sm font-medium text-stone-700 dark:text-stone-300">Sequential Mode (Include Duplicates)</label>
                </div>
            </div>        
        </section>

        <section id="emojiSequenceSection" class="mb-8 hidden">
            <h2 class="text-2xl font-semibold text-stone-700 mt-8 mb-4 dark:text-stone-200">Emoji Sequence Details:</h2>
            <div class="overflow-x-auto rounded-lg border border-stone-200 shadow-sm dark:border-stone-700">
                <table id="emojiSequenceTable" class="min-w-full divide-y divide-stone-300 dark:divide-stone-600">
                    <thead class="bg-stone-200 dark:bg-stone-700">
                        <tr>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Sequence</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Name</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Codepoints (U+)</th>
                        </tr>
                    </thead>
                    <tbody id="emojiSequenceBody" class="bg-white divide-y divide-stone-200 dark:bg-stone-800 dark:divide-stone-700">
                    </tbody>
                </table>
            </div>
        </section>
        
        <section id="individualCharacterDetailsSection" class="hidden">
            <h2 class="text-2xl font-semibold text-stone-700 mt-8 mb-4 dark:text-stone-200">Individual Character Details:</h2>
            <div id="messageArea" class="text-stone-600 mb-4 p-4 bg-stone-50 rounded-lg border border-stone-200 dark:bg-stone-700 dark:border-stone-600 dark:text-stone-300">
                Paste text above or use lookup options, then click 'Analyze Text Above' to see character details.
            </div>
            <div class="overflow-x-auto rounded-lg border border-stone-200 shadow-sm dark:border-stone-700">
                <table id="resultsTable" class="min-w-full divide-y divide-stone-300 hidden dark:divide-stone-600">
                    <thead class="bg-stone-200 dark:bg-stone-700">
                        <tr>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Char</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Codepoint (U+)</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Name</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Code Point</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">UTF-8</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">UTF-16</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">UTF-16 LE</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Block</th>
                        </tr>
                    </thead>
                    <tbody id="resultsBody" class="bg-white divide-y divide-stone-200 dark:bg-stone-800 dark:divide-stone-700">
                    </tbody>
                </table>
            </div>
        </section>

        <section id="blocksSummarySection" class="mt-8 mb-8 hidden">
            <h2 class="text-2xl font-semibold text-stone-700 mb-4 dark:text-stone-200">Unicode Blocks in Text:</h2>
            <div class="overflow-x-auto rounded-lg border border-stone-200 shadow-sm dark:border-stone-700">
                <table id="blocksSummaryTable" class="min-w-full divide-y divide-stone-300 dark:divide-stone-600">
                    <thead class="bg-stone-200 dark:bg-stone-700">
                        <tr>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Block Name</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Range (Hex)</th>
                            <th scope="col" class="px-4 py-3 text-left text-xs font-medium text-stone-600 uppercase tracking-wider dark:text-stone-300">Chart</th>
                        </tr>
                    </thead>
                    <tbody id="blocksSummaryBody" class="bg-white divide-y divide-stone-200 dark:bg-stone-800 dark:divide-stone-700">
                    </tbody>
                </table>
            </div>
        </section>
    </div>

    <footer class="mt-12 text-center text-stone-500 text-sm w-full max-w-7xl dark:text-stone-400">
        <div id="dataStatusFooter" class="p-4 bg-stone-100 rounded-lg text-sm text-stone-700 border border-stone-200 hidden dark:bg-stone-800 dark:border-stone-700 dark:text-stone-300">
             <h3 class="font-semibold text-base text-stone-800 mb-3 text-center dark:text-stone-200">Data File Status</h3>
             <div id="statusGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                <div id="blocksStatus" class="p-3 bg-white rounded-lg border border-stone-300 shadow-sm dark:bg-stone-700 dark:border-stone-600"></div>
                <div id="unicodeDataStatus" class="p-3 bg-white rounded-lg border border-stone-300 shadow-sm dark:bg-stone-700 dark:border-stone-600"></div>
                <div id="chartLinksStatus" class="p-3 bg-white rounded-lg border border-stone-300 shadow-sm dark:bg-stone-700 dark:border-stone-600"></div>
                <div id="emojiDataStatus" class="p-3 bg-white rounded-lg border border-stone-300 shadow-sm dark:bg-stone-700 dark:border-stone-600"></div>
             </div>
        </div>
        <p class="mt-4">
			By ThioJoe &nbsp;|&nbsp; 
			<a href="https://github.com/ThioJoe/Browser-Based-Tools" class="text-sky-600 hover:underline dark:text-sky-400 inline-flex items-center">
				Project on GitHub
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" class="w-4 h-4 ml-1.5">
					<path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
				</svg>
			</a>
		</p>
    </footer>

    <script>
        let blocksJsLoaded = false; 
        let unicodeDataJsLoaded = false; 
        let chartLinksJsLoaded = false;
        let emojiDataJsLoaded = false;

        function handleBlocksJsError() { blocksJsLoaded = false; }
        function handleUnicodeDataJsError() { unicodeDataJsLoaded = false; }
        function handleChartLinksJsError() { chartLinksJsLoaded = false; }
        function handleEmojiDataJsError() { emojiDataJsLoaded = false; }


        const textInputElement = document.getElementById('textInput');
        const analyzeButtonElement = document.getElementById('analyzeButton');
        const resultsTableElement = document.getElementById('resultsTable');
        const resultsBodyElement = document.getElementById('resultsBody');
        const messageAreaElement = document.getElementById('messageArea');
        const lookupMessageAreaElement = document.getElementById('lookupMessageArea');

        const blocksSummarySectionElement = document.getElementById('blocksSummarySection');
        const blocksSummaryBodyElement = document.getElementById('blocksSummaryBody');
        const emojiSequenceSectionElement = document.getElementById('emojiSequenceSection');
        const emojiSequenceBodyElement = document.getElementById('emojiSequenceBody');
		const individualCharacterDetailsSectionElement = document.getElementById('individualCharacterDetailsSection');
        const sequentialModeCheckboxElement = document.getElementById('sequentialModeCheckbox');
        
        const setupContainerElement = document.getElementById('setupContainer');

        const blocksSetupSectionElement = document.getElementById('blocksSetupSection');
        const blocksSetupInstructionsElement = document.getElementById('blocksSetupInstructions');
        const blocksFileUploadElement = document.getElementById('blocksFileUpload');
        const blocksGenerateButtonElement = document.getElementById('blocksGenerateButton');
        let selectedBlocksFileContent = null;

        const unicodeDataSetupSectionElement = document.getElementById('unicodeDataSetupSection');
        const unicodeDataSetupInstructionsElement = document.getElementById('unicodeDataSetupInstructions');
        const unicodeDataFileUploadElement = document.getElementById('unicodeDataFileUpload');
        const unicodeDataGenerateButtonElement = document.getElementById('unicodeDataGenerateButton');
        let selectedUnicodeDataFileContent = null;

        const chartLinksSetupSectionElement = document.getElementById('chartLinksSetupSection');
        const chartLinksSetupInstructionsElement = document.getElementById('chartLinksSetupInstructions');
        const chartLinksFileUploadElement = document.getElementById('chartLinksFileUpload');
        const chartLinksGenerateButtonElement = document.getElementById('chartLinksGenerateButton');
        let selectedChartLinksFileContent = null;

        const emojiDataSetupSectionElement = document.getElementById('emojiDataSetupSection');
        const emojiDataSetupInstructionsElement = document.getElementById('emojiDataSetupInstructions');
        const emojiDataFileUploadElement = document.getElementById('emojiDataFileUpload');
        const emojiDataGenerateButtonElement = document.getElementById('emojiDataGenerateButton');
        let selectedEmojiDataFileContent = null;


        // Lookup elements
        const codepointInputElement = document.getElementById('codepointInput');
        const lookupByCodepointButtonElement = document.getElementById('lookupByCodepointButton');
        const nameInputElement = document.getElementById('nameInput');
        const lookupByNameButtonElement = document.getElementById('lookupByNameButton');

        const utf8Encoder = new TextEncoder();

        let unicodeBlocks = [ 
            { start: 0x0000, end: 0x007F, name: "Basic Latin" },
            { start: 0x0080, end: 0x00FF, name: "Latin-1 Supplement" },
            { start: 0x2000, end: 0x206F, name: "General Punctuation" }
        ];
        let unicodeCharacterNames = {}; 
        let unicodeAlgorithmicNameRangesArray = []; 
        let unicodeChartLinks = {}; 
        let emojiSequenceData = {}; // Stores { "CODPOINT SEQUENCE": { emoji: "ðŸ˜€", name: "grinning face" } }

        analyzeButtonElement.addEventListener('click', () => analyzeText(textInputElement.value));
        lookupByCodepointButtonElement.addEventListener('click', handleLookupByCodepoint);
        lookupByNameButtonElement.addEventListener('click', handleLookupByName);
        
        function showLookupMessage(message, isError = false) { showMessageInArea(lookupMessageAreaElement, message, isError); }
        
        function showMessageInArea(areaElement, message, isError = false) {
            areaElement.textContent = message;
            areaElement.classList.remove('hidden');
            areaElement.classList.toggle('text-red-600', isError);
            areaElement.classList.toggle('text-green-600', !isError && message.includes('successfully'));
            areaElement.classList.toggle('text-blue-600', !isError && !message.includes('successfully') && !message.includes('Error') && !message.includes('found'));
            areaElement.classList.toggle('text-orange-600', !isError && (message.includes('No character found') || message.includes('No characters found')));
        }

        function setupFileUploader(fileInputElement, generateButtonElement, instructionElement, contentVarSetter, successCallback) {
            fileInputElement.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    contentVarSetter(e.target.result);
                    generateButtonElement.disabled = false;
                    instructionElement.innerHTML = `File <code>${file.name}</code> ready. Click to generate.`;
                    instructionElement.classList.add('text-green-700', 'font-semibold');
                };
                reader.readAsText(file);
            });
            generateButtonElement.addEventListener('click', successCallback);
        }
        
        setupFileUploader(blocksFileUploadElement, blocksGenerateButtonElement, blocksSetupInstructionsElement, (content) => selectedBlocksFileContent = content, generateAndDownloadBlocksJs);
        setupFileUploader(unicodeDataFileUploadElement, unicodeDataGenerateButtonElement, unicodeDataSetupInstructionsElement, (content) => selectedUnicodeDataFileContent = content, generateAndDownloadUnicodeDataJs);
        setupFileUploader(chartLinksFileUploadElement, chartLinksGenerateButtonElement, chartLinksSetupInstructionsElement, (content) => selectedChartLinksFileContent = content, generateAndDownloadChartLinksJs);
        setupFileUploader(emojiDataFileUploadElement, emojiDataGenerateButtonElement, emojiDataSetupInstructionsElement, (content) => selectedEmojiDataFileContent = content, generateAndDownloadEmojiDataJs);


        function generateAndDownloadBlocksJs() {
            if (!selectedBlocksFileContent) { showLookupMessage('No file content for _Blocks.js.', true); return; }
            const jsContent = `const EXTERNAL_UNICODE_BLOCKS_DATA = \`${selectedBlocksFileContent}\`;`;
            downloadJsFile(jsContent, '_Blocks.js');
            blocksSetupInstructionsElement.innerHTML = "Download started! Save <code>_Blocks.js</code> in this folder, then refresh.";
        }
        function generateAndDownloadUnicodeDataJs() {
            if (!selectedUnicodeDataFileContent) { showLookupMessage('No file content for _UnicodeData.js.', true); return; }
            const parsedData = parseUnicodeData(selectedUnicodeDataFileContent);
            if (Object.keys(parsedData.characterNames).length === 0 && parsedData.algorithmicNameRanges.length === 0) {
                showLookupMessage('Could not parse any data from UnicodeData.txt.', true); return;
            }
            const namesObjStr = JSON.stringify(parsedData.characterNames); 
            const rangesArrayStr = JSON.stringify(parsedData.algorithmicNameRanges); 
            const jsContent = `const EXTERNAL_UNICODE_CHARACTER_NAMES = ${namesObjStr};\nconst EXTERNAL_UNICODE_ALGORITHMIC_RANGES = ${rangesArrayStr};`;
            downloadJsFile(jsContent, '_UnicodeData.js');
            unicodeDataSetupInstructionsElement.innerHTML = "Download started! Save <code>_UnicodeData.js</code> in this folder, then refresh.";
        }
        function generateAndDownloadChartLinksJs() {
            if (!selectedChartLinksFileContent) { showLookupMessage('No file content for _ChartLinks.js.', true); return; }
            const parsedLinks = parseChartListTxt(selectedChartLinksFileContent);
             if (Object.keys(parsedLinks).length === 0) { showLookupMessage('Could not parse chart links.', true); return; }
            const linksObjStr = JSON.stringify(parsedLinks); 
            const jsContent = `const EXTERNAL_UNICODE_CHART_LINKS = ${linksObjStr};`;
            downloadJsFile(jsContent, '_ChartLinks.js');
            chartLinksSetupInstructionsElement.innerHTML = "Download started! Save <code>_ChartLinks.js</code> in this folder, then refresh.";
        }
         function generateAndDownloadEmojiDataJs() {
            if (!selectedEmojiDataFileContent) { showLookupMessage('No file content for _EmojiData.js.', true); return; }
            const parsedEmoji = parseEmojiOrderingTxt(selectedEmojiDataFileContent);
            if (Object.keys(parsedEmoji).length === 0) { showLookupMessage('Could not parse emoji data.', true); return; }
            const emojiObjStr = JSON.stringify(parsedEmoji); 
            const jsContent = `const EXTERNAL_EMOJI_SEQUENCES = ${emojiObjStr};`;
            downloadJsFile(jsContent, '_EmojiData.js');
            emojiDataSetupInstructionsElement.innerHTML = "Download started! Save <code>_EmojiData.js</code> in this folder, then refresh.";
        }


        function downloadJsFile(content, filename) {
            const blob = new Blob([content], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function parseBlocksTxt(data) {
            const lines = data.split('\n');
            const blocks = [];
            const blockRegex = /^([0-9A-Fa-f]{4,6})\.\.([0-9A-Fa-f]{4,6});\s*(.+)$/;
            for (const line of lines) {
                if (line.startsWith('#') || line.trim() === '') { continue; }
                const match = line.match(blockRegex);
                if (match) {
                    blocks.push({ start: parseInt(match[1], 16), end: parseInt(match[2], 16), name: match[3].trim() });
                }
            }
            return blocks;
        }

        function parseUnicodeData(data) {
            const characterNames = {};
            const algorithmicNameRanges = [];
            const lines = data.split('\n');
            let currentRange = null;

            for (const line of lines) {
                if (line.trim() === '' || line.startsWith('#')) continue;
                const parts = line.split(';');
                if (parts.length < 2) continue;

                const codepointHex = parts[0].toUpperCase();
                let name = parts[1];

                if (name.startsWith('<') && name.endsWith(', First>')) {
                    const baseName = name.substring(1, name.length - ', First>'.length);
                    let type = 'GENERIC_RANGE';
                    let namePrefix = baseName.toUpperCase() + " ";
                    if (baseName.includes('CJK Ideograph')) type = 'CJK';
                    else if (baseName.includes('Hangul Syllable')) type = 'HANGUL';
                    else if (baseName.includes('Surrogate')) type = 'SURROGATE';
                    else if (baseName.includes('Private Use')) type = 'PRIVATE_USE';
                    
                    currentRange = {
                        start: parseInt(codepointHex, 16),
                        namePrefix: namePrefix,
                        baseName: baseName, 
                        type: type
                    };
                } else if (name.startsWith('<') && name.endsWith(', Last>')) {
                    if (currentRange && name.substring(1, name.length - ', Last>'.length) === currentRange.baseName) {
                        currentRange.end = parseInt(codepointHex, 16);
                        if (currentRange.type === 'CJK') currentRange.namePrefix = 'CJK UNIFIED IDEOGRAPH-';
                        else if (currentRange.type === 'HANGUL') currentRange.namePrefix = 'HANGUL SYLLABLE ';
                        algorithmicNameRanges.push({...currentRange});
                        currentRange = null;
                    }
                } else if (name === "<control>") {
                    characterNames[codepointHex] = (parts.length > 10 && parts[10]) ? parts[10] : `CONTROL CHARACTER ${codepointHex}`;
                } else {
                    characterNames[codepointHex] = name;
                }
            }
            return { characterNames, algorithmicNameRanges };
        }

        function parseChartListTxt(data) {
            const chartLinks = {};
            const lines = data.split('\n');
            const chartRegex = /U([0-9A-Fa-f]{4,6})\.pdf$/; 
            for (const line of lines) {
                const parts = line.trim().split(/\s+/); 
                if (parts.length > 0) {
                    const lastPart = parts[parts.length - 1]; 
                    const match = lastPart.match(chartRegex);
                    if (match) {
                        const codepointStartHex = match[1].toUpperCase(); 
                        chartLinks[codepointStartHex] = lastPart; 
                    }
                }
            }
            return chartLinks;
        }

        function parseEmojiOrderingTxt(data) {
            const emojiMap = {};
            const lines = data.split('\n');
            for (const line of lines) {
                if (line.startsWith('#') || line.trim() === '') continue;
                const parts = line.split(';');
                if (parts.length < 2) continue;

                const codepointSequenceStr = parts[0].trim().replace(/U\+/g, '').toUpperCase(); 
                
                const commentPart = parts.slice(1).join(';'); 
                const hashIndex = commentPart.indexOf('#');
                if (hashIndex === -1) continue;

                const emojiCharAndName = commentPart.substring(hashIndex + 1).trim();
                let emojiChar = "";
                let name = "";
                let nameStartIndex = 0;

                // Heuristic to extract the emoji character(s) first
                // This tries to grab the visible emoji and treat the rest as its name
                let k = 0;
                while(k < emojiCharAndName.length) {
                    const firstSpaceIndex = emojiCharAndName.indexOf(' ', k);
                    const potentialEmoji = (firstSpaceIndex === -1) ? emojiCharAndName.substring(k) : emojiCharAndName.substring(k, firstSpaceIndex);
                    
                    // Check if the potentialEmoji is likely an emoji or part of one
                    // This is a simplified check; a more robust one might check Unicode properties
                    let isLikelyEmoji = false;
                    if (potentialEmoji.length > 0) {
                        const cp = potentialEmoji.codePointAt(0);
                        if (cp > 0xFFF || (cp >= 0x2600 && cp <= 0x27BF) || potentialEmoji.includes('\u200D') || potentialEmoji.includes('\uFE0F')) {
                            isLikelyEmoji = true;
                        }
                    }

                    if (isLikelyEmoji) {
                        emojiChar += potentialEmoji;
                        k = (firstSpaceIndex === -1) ? emojiCharAndName.length : firstSpaceIndex + 1;
                        if (firstSpaceIndex !== -1 && emojiCharAndName.charAt(k-1) === ' ' && emojiCharAndName.charAt(k) !== ' ') {
                             // if there was a space, and next is not a space, it's likely the start of the name
                        } else if (firstSpaceIndex !== -1) {
                             emojiChar += ' '; // keep space if it's part of multi-char emoji like flags
                        }
                    } else {
                        break; // Assume rest is the name
                    }
                }
                emojiChar = emojiChar.trim();
                name = emojiCharAndName.substring(k).trim();

                if (!emojiChar && name) { // If emojiChar is empty but name is not, take first "word" as emoji
                     const nameParts = name.split(' ');
                     emojiChar = nameParts[0];
                     name = nameParts.slice(1).join(' ');
                }
                if (!name && emojiChar) { // If name is empty but emojiChar is not, it might be that the whole thing was emoji
                    name = emojiChar; // This can happen for single char emoji where the split logic fails.
                }


                if (codepointSequenceStr && name && emojiChar) {
                    emojiMap[codepointSequenceStr] = { emoji: emojiChar, name: name };
                } else if (codepointSequenceStr && emojiCharAndName) { // Fallback if parsing is tricky
                     emojiMap[codepointSequenceStr] = { emoji: emojiCharAndName.split(' ')[0], name: emojiCharAndName.substring(emojiCharAndName.indexOf(' ')+1).trim() };
                }
            }
            return emojiMap;
        }

        function renderStatus(element, isLoaded, name, details, sourceUrl, sourceFileName, contentVarSetter, generationFunction) {
            element.innerHTML = ''; // Clear previous content

            const statusDiv = document.createElement('div');
            statusDiv.className = 'font-semibold flex items-center';

            const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            icon.setAttribute('class', `flex-shrink-0 w-5 h-5 mr-2 ${isLoaded ? 'text-green-600' : 'text-red-600'}`);
            icon.setAttribute('viewBox', '0 0 20 20');
            icon.setAttribute('fill', 'currentColor');
            if (isLoaded) {
                icon.innerHTML = `<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />`;
            } else {
                icon.innerHTML = `<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />`;
            }

            statusDiv.appendChild(icon);
            statusDiv.appendChild(document.createTextNode(name));

            const detailsP = document.createElement('p');
            detailsP.className = 'text-xs text-stone-600 ml-7 dark:text-stone-400';
            detailsP.textContent = details;
            
            // Always visible source link
            const sourceLinkDiv = document.createElement('div');
            sourceLinkDiv.className = 'text-xs mt-2';
            sourceLinkDiv.innerHTML = `<a href="${sourceUrl}" target="_blank" rel="noopener noreferrer" class="text-sky-700 hover:text-sky-900 underline inline-flex items-center dark:text-sky-400 dark:hover:text-sky-200">Download Source: ${sourceFileName} <svg class="download-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path d="M10.75 2.75a.75.75 0 00-1.5 0v8.614L6.295 8.235a.75.75 0 10-1.09 1.03l4.25 4.5a.75.75 0 001.09 0l4.25-4.5a.75.75 0 00-1.09-1.03l-2.905 3.079V2.75z" /><path d="M3.5 12.75a.75.75 0 00-1.5 0v2.5A2.75 2.75 0 004.75 18h10.5A2.75 2.75 0 0018 15.25v-2.5a.75.75 0 00-1.5 0v2.5c0 .69-.56 1.25-1.25 1.25H4.75c-.69 0-1.25-.56-1.25-1.25v-2.5z" /></svg></a>`;
            
            // Regenerate link and hidden file input
            const regenerateLabel = document.createElement('label');
            regenerateLabel.className = 'text-xs text-green-700 hover:underline mt-1 cursor-pointer inline-block dark:text-green-400 dark:hover:text-green-200';
            regenerateLabel.textContent = 'Regenerate .js File...';

            const regenerateInput = document.createElement('input');
            regenerateInput.type = 'file';
            regenerateInput.accept = '.txt';
            regenerateInput.className = 'hidden';
            regenerateInput.addEventListener('change', (event) => {
                handleRegenerateFile(event, contentVarSetter, generationFunction);
            });
            
            regenerateLabel.appendChild(regenerateInput);

            element.appendChild(statusDiv);
            element.appendChild(detailsP);
            element.appendChild(sourceLinkDiv);
            element.appendChild(regenerateLabel);
        }
		
		function handleRegenerateFile(event, contentVarSetter, generationFunction) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                contentVarSetter(e.target.result);
                generationFunction();
                // Reset the input value to allow re-selecting the same file again
                event.target.value = null; 
            };
            reader.readAsText(file);
        }
        
        window.onload = function() {
            setTimeout(() => {
                let successfulLoads = 0;
                document.getElementById('dataStatusFooter').classList.remove('hidden');

                // 1. Check for _Blocks.js
                if (typeof EXTERNAL_UNICODE_BLOCKS_DATA !== 'undefined') {
                    const newBlocks = parseBlocksTxt(EXTERNAL_UNICODE_BLOCKS_DATA);
                    if (newBlocks.length > 0) {
                        unicodeBlocks = newBlocks;
                        successfulLoads++;
                        renderStatus(document.getElementById('blocksStatus'), true, 'Block Data', `${newBlocks.length} definitions loaded`, 'https://www.unicode.org/Public/UNIDATA/Blocks.txt', 'Blocks.txt', (content) => selectedBlocksFileContent = content, generateAndDownloadBlocksJs);
                    } else {
                        renderStatus(document.getElementById('blocksStatus'), false, 'Block Data', 'File found but empty', 'https://www.unicode.org/Public/UNIDATA/Blocks.txt', 'Blocks.txt', (content) => selectedBlocksFileContent = content, generateAndDownloadBlocksJs);
                        blocksSetupSectionElement.classList.remove('hidden');
                    }
                } else {
                    renderStatus(document.getElementById('blocksStatus'), false, 'Block Data', 'Not loaded, using defaults', 'https://www.unicode.org/Public/UNIDATA/Blocks.txt', 'Blocks.txt', (content) => selectedBlocksFileContent = content, generateAndDownloadBlocksJs);
                    blocksSetupSectionElement.classList.remove('hidden');
                }

                // 2. Check for _UnicodeData.js
                if (typeof EXTERNAL_UNICODE_CHARACTER_NAMES !== 'undefined' && typeof EXTERNAL_UNICODE_ALGORITHMIC_RANGES !== 'undefined') {
                    unicodeCharacterNames = EXTERNAL_UNICODE_CHARACTER_NAMES;
                    unicodeAlgorithmicNameRangesArray = EXTERNAL_UNICODE_ALGORITHMIC_RANGES;
                    const nameCount = Object.keys(unicodeCharacterNames).length + unicodeAlgorithmicNameRangesArray.reduce((sum, range) => sum + (range.end - range.start + 1), 0);
                    successfulLoads++;
                    renderStatus(document.getElementById('unicodeDataStatus'), true, 'Character Data', `~${nameCount.toLocaleString()} names loaded`, 'https://www.unicode.org/Public/UNIDATA/UnicodeData.txt', 'UnicodeData.txt', (content) => selectedUnicodeDataFileContent = content, generateAndDownloadUnicodeDataJs);
                } else {
                    renderStatus(document.getElementById('unicodeDataStatus'), false, 'Character Data', 'Not loaded', 'https://www.unicode.org/Public/UNIDATA/UnicodeData.txt', 'UnicodeData.txt', (content) => selectedUnicodeDataFileContent = content, generateAndDownloadUnicodeDataJs);
                    unicodeDataSetupSectionElement.classList.remove('hidden');
                }

                // 3. Check for _ChartLinks.js
                if (typeof EXTERNAL_UNICODE_CHART_LINKS !== 'undefined') {
                    unicodeChartLinks = EXTERNAL_UNICODE_CHART_LINKS;
                    successfulLoads++;
                    renderStatus(document.getElementById('chartLinksStatus'), true, 'Chart Links', `${Object.keys(unicodeChartLinks).length} links loaded`, 'https://www.unicode.org/charts/PDF/unversionedchartlist.txt', 'unversionedchartlist.txt', (content) => selectedChartLinksFileContent = content, generateAndDownloadChartLinksJs);
                } else {
                    renderStatus(document.getElementById('chartLinksStatus'), false, 'Chart Links', 'Not loaded', 'https://www.unicode.org/charts/PDF/unversionedchartlist.txt', 'unversionedchartlist.txt', (content) => selectedChartLinksFileContent = content, generateAndDownloadChartLinksJs);
                    chartLinksSetupSectionElement.classList.remove('hidden');
                }
                
                // 4. Check for _EmojiData.js
                if (typeof EXTERNAL_EMOJI_SEQUENCES !== 'undefined') {
                    emojiSequenceData = EXTERNAL_EMOJI_SEQUENCES;
                    successfulLoads++;
                     renderStatus(document.getElementById('emojiDataStatus'), true, 'Emoji Data', `${Object.keys(emojiSequenceData).length} sequences loaded`, 'https://unicode.org/emoji/charts/emoji-ordering.txt', 'emoji-ordering.txt', (content) => selectedEmojiDataFileContent = content, generateAndDownloadEmojiDataJs);
                } else {
                     renderStatus(document.getElementById('emojiDataStatus'), false, 'Emoji Data', 'Not loaded', 'https://unicode.org/emoji/charts/emoji-ordering.txt', 'emoji-ordering.txt', (content) => selectedEmojiDataFileContent = content, generateAndDownloadEmojiDataJs);
                    emojiDataSetupSectionElement.classList.remove('hidden');
                }

                if(successfulLoads < 4) {
					setupContainerElement.classList.remove('hidden');
				}

            }, 100);
        };

        function handleLookupByCodepoint() {
            const rawInput = codepointInputElement.value.trim().replace(/\s+/g, ''); 
            if (!rawInput) {
                showLookupMessage("Please enter a codepoint.", true);
                return;
            }
            const normalizedInput = rawInput.toUpperCase().startsWith('U+') ? rawInput.substring(2) : rawInput;
            
            if (!/^[0-9A-F]{4,6}$/.test(normalizedInput)) {
                showLookupMessage("Invalid codepoint format. Use 4-6 hex digits (e.g., 0041 or U+1F600).", true);
                return;
            }

            const codepointInt = parseInt(normalizedInput, 16);
            if (isNaN(codepointInt) || codepointInt > 0x10FFFF) {
                 showLookupMessage("Invalid codepoint value.", true);
                 return;
            }
            
            try {
                const char = String.fromCodePoint(codepointInt);
                textInputElement.value = char; 
                analyzeText(char); 
                showLookupMessage(`Displaying character for U+${normalizedInput}.`, false);
            } catch (e) {
                showLookupMessage(`Error converting codepoint U+${normalizedInput} to character.`, true);
                console.error(e);
            }
        }

        function handleLookupByName() {
            const nameQuery = nameInputElement.value.trim().toLowerCase();
            if (!nameQuery) {
                showLookupMessage("Please enter a name to search.", true);
                return;
            }

            if (Object.keys(unicodeCharacterNames).length === 0 && unicodeAlgorithmicNameRangesArray.length === 0 && Object.keys(emojiSequenceData).length === 0) {
                showLookupMessage("Unicode name data (characters or emoji) is not loaded. Please generate relevant .js files first.", true);
                return;
            }

            let foundChars = "";
            const MAX_NAME_LOOKUP_RESULTS = 50; 
            let resultsCount = 0;

            // Search in explicit character names
            for (const cpHex in unicodeCharacterNames) {
                if (resultsCount >= MAX_NAME_LOOKUP_RESULTS) break;
                if (unicodeCharacterNames[cpHex].toLowerCase().includes(nameQuery)) {
                    foundChars += String.fromCodePoint(parseInt(cpHex, 16));
                    resultsCount++;
                }
            }
            // Search in emoji sequence names
            for (const seqKey in emojiSequenceData) {
                if (resultsCount >= MAX_NAME_LOOKUP_RESULTS) break;
                if (emojiSequenceData[seqKey].name.toLowerCase().includes(nameQuery)) {
                    // Reconstruct emoji from sequence key for display
                    const emojiFromSeq = seqKey.split(' ').map(cp => String.fromCodePoint(parseInt(cp, 16))).join('');
                    foundChars += emojiFromSeq;
                    resultsCount++;
                }
            }
            
            if (foundChars) {
                textInputElement.value = foundChars; 
                analyzeText(foundChars);
                showLookupMessage(`Found ${resultsCount} character(s)/sequence(s) matching "${nameInputElement.value.trim()}". Displaying details.`, false);
            } else {
                resultsBodyElement.innerHTML = '';
                resultsTableElement.classList.add('hidden');
                blocksSummaryBodyElement.innerHTML = '';
                blocksSummarySectionElement.classList.add('hidden');
                emojiSequenceBodyElement.innerHTML = '';
                emojiSequenceSectionElement.classList.add('hidden');
                showLookupMessage(`No characters or sequences found with a name containing "${nameInputElement.value.trim()}".`, false);
            }
        }

        function analyzeText(inputTextValue) { 
            resultsBodyElement.innerHTML = ''; 
            blocksSummaryBodyElement.innerHTML = ''; 
            // emojiSequenceBodyElement is cleared in identifyAndDisplayEmojiSequences
            
            if (!inputTextValue) { 
                messageAreaElement.textContent = 'Input text is empty.';
                messageAreaElement.classList.remove('hidden');
                resultsTableElement.classList.add('hidden');
                individualCharacterDetailsSectionElement.classList.add('hidden');
                blocksSummarySectionElement.classList.add('hidden');
                emojiSequenceSectionElement.classList.add('hidden');
                lookupMessageAreaElement.classList.add('hidden'); 
                return;
            }
            messageAreaElement.classList.add('hidden');
            resultsTableElement.classList.remove('hidden');
            individualCharacterDetailsSectionElement.classList.remove('hidden');
            
            const isSequentialMode = sequentialModeCheckboxElement.checked;
            let charactersToAnalyze;

            if (isSequentialMode) {
                charactersToAnalyze = Array.from(inputTextValue); // All characters in order
            } else {
                charactersToAnalyze = Array.from(new Set(Array.from(inputTextValue, char => char))); // Unique characters
            }
            
            if (charactersToAnalyze.length === 0) {
                messageAreaElement.textContent = 'No processable characters found.';
                messageAreaElement.classList.remove('hidden');
                resultsTableElement.classList.add('hidden');
                individualCharacterDetailsSectionElement.classList.add('hidden');
                blocksSummarySectionElement.classList.add('hidden');
                emojiSequenceSectionElement.classList.add('hidden');
                return;
            }

            const foundBlocksInText = new Map(); 

            const charCountForMessage = charactersToAnalyze.length;
            const charTypeMessage = isSequentialMode ? "characters" : "unique characters";

            if (charCountForMessage > 200 && inputTextValue === textInputElement.value) { 
                showLookupMessage(`Found ${charCountForMessage} ${charTypeMessage}. Displaying the first 200.`, false);
            } else if (inputTextValue !== textInputElement.value) { 
                 lookupMessageAreaElement.classList.remove('hidden'); 
            }


            let count = 0;
            charactersToAnalyze.forEach(char => {
                if (count++ >= 200 && inputTextValue === textInputElement.value) return; 

                const codepointInt = char.codePointAt(0);
                const uPlusFormatted = formatCodepoint(codepointInt);
                const characterName = findCharacterName(codepointInt);
                const codepointHex = codepointInt.toString(16).toUpperCase().padStart(4, '0');
                const utf8Hex = getUtf8HexBytes(char);
                const utf16Hex = getUtf16HexCodeUnits(char);
                const utf16LEHex = getUtf16LEHexCodeUnits(char);
                const blockInfo = findBlockInfo(codepointInt); 
                const blockName = blockInfo ? blockInfo.name : 'N/A';

                if (blockInfo && !foundBlocksInText.has(blockInfo.name)) {
                    foundBlocksInText.set(blockInfo.name, blockInfo);
                }

                const row = resultsBodyElement.insertRow();
                
                let cellIndex = 0;
                row.insertCell(cellIndex++).textContent = char;
                row.cells[0].classList.add('px-4', 'py-3', 'text-lg', 'font-mono', 'table-cell-valign');
                
                row.insertCell(cellIndex++).textContent = uPlusFormatted;
                row.cells[1].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'font-mono', 'table-cell-valign', 'dark:text-stone-300');
                
                row.insertCell(cellIndex++).textContent = characterName;
                row.cells[2].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'table-cell-valign', 'dark:text-stone-300');

                row.insertCell(cellIndex++).textContent = codepointHex;
                row.cells[3].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'font-mono', 'table-cell-valign', 'dark:text-stone-300');
                
                row.insertCell(cellIndex++).textContent = utf8Hex;
                row.cells[4].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'font-mono', 'table-cell-valign', 'whitespace-nowrap', 'dark:text-stone-300');
                
                row.insertCell(cellIndex++).textContent = utf16Hex;
                row.cells[5].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'font-mono', 'table-cell-valign', 'whitespace-nowrap', 'dark:text-stone-300');

                row.insertCell(cellIndex++).textContent = utf16LEHex;
                row.cells[6].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'font-mono', 'table-cell-valign', 'whitespace-nowrap', 'dark:text-stone-300');
                
                row.insertCell(cellIndex++).textContent = blockName;
                row.cells[7].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'table-cell-valign', 'dark:text-stone-300');
            });

            if (foundBlocksInText.size > 0) {
                blocksSummarySectionElement.classList.remove('hidden');
                foundBlocksInText.forEach(block => {
                    const row = blocksSummaryBodyElement.insertRow();
                    row.insertCell().textContent = block.name;
                    row.insertCell().textContent = `${block.start.toString(16).toUpperCase().padStart(4, '0')} - ${block.end.toString(16).toUpperCase().padStart(4, '0')}`;
                    const chartCell = row.insertCell();
                    const blockStartHexForChart = block.start.toString(16).toUpperCase().padStart(4,'0');
                    const pdfFileName = unicodeChartLinks[blockStartHexForChart];
                    if (pdfFileName) {
                        const link = document.createElement('a');
                        link.href = `https://www.unicode.org/charts/PDF/${pdfFileName}`;
                        link.textContent = 'PDF';
                        link.target = '_blank';
                        link.rel = 'noopener noreferrer';
                        link.classList.add('text-sky-600', 'hover:text-sky-800', 'underline', 'dark:text-sky-400', 'dark:hover:text-sky-200');
                        chartCell.appendChild(link);
                    } else { chartCell.textContent = 'N/A'; }
                     row.cells[0].classList.add('px-4', 'py-2', 'text-sm', 'text-stone-700', 'dark:text-stone-300');
                     row.cells[1].classList.add('px-4', 'py-2', 'text-sm', 'text-stone-700', 'font-mono', 'dark:text-stone-300');
                     row.cells[2].classList.add('px-4', 'py-2', 'text-sm');
                });
            } else {
                blocksSummarySectionElement.classList.add('hidden');
            }

            // Analyze and display emoji sequences (this function operates on the original inputTextValue)
            identifyAndDisplayEmojiSequences(inputTextValue);
        }

        function identifyAndDisplayEmojiSequences(text) {
            emojiSequenceBodyElement.innerHTML = ''; // Clear previous
            if (Object.keys(emojiSequenceData).length === 0) {
                emojiSequenceSectionElement.classList.add('hidden');
                return;
            }

            const foundSequences = [];
            let i = 0;
            const textChars = Array.from(text); 

            while (i < textChars.length) {
                let longestMatch = null;
                let longestMatchLength = 0;

                for (let len = Math.min(10, textChars.length - i); len > 0; len--) { 
                    const subArray = textChars.slice(i, i + len);
                    const codepointHexArray = subArray.map(ch => ch.codePointAt(0).toString(16).toUpperCase());
                    const codepointSequenceKey = codepointHexArray.join(' ');
                    
                    if (emojiSequenceData[codepointSequenceKey]) {
                        longestMatch = {
                            sequenceString: subArray.join(''),
                            data: emojiSequenceData[codepointSequenceKey],
                            codepointsUPlus: codepointHexArray.map(cp => `U+${cp.padStart(4,'0')}`).join(' '),
                            individualCodepointsHex: codepointHexArray // Store individual hex codepoints
                        };
                        longestMatchLength = len;
                        break; 
                    }
                }

                if (longestMatch) {
                    foundSequences.push(longestMatch);
                    i += longestMatchLength; 
                } else {
                    i++; 
                }
            }

            if (foundSequences.length > 0) {
                emojiSequenceSectionElement.classList.remove('hidden');
                foundSequences.forEach(seq => {
                    const row = emojiSequenceBodyElement.insertRow();

                    const sequenceCell = row.insertCell();
                    sequenceCell.classList.add('px-4', 'py-3', 'text-xl', 'font-mono', 'flex', 'items-center'); // Use flex for alignment

                    // Icon container - always present for alignment
                    const iconContainer = document.createElement('span');
                    iconContainer.style.display = 'inline-block';
                    iconContainer.style.width = '16px'; // Reserve space for icon (adjust as needed)
                    iconContainer.style.height = '16px'; // Reserve space for icon
                    iconContainer.style.marginRight = '8px'; // Space between icon and emoji text
                    iconContainer.style.flexShrink = '0'; // Prevent shrinking if emoji is long

                    if (seq.individualCodepointsHex.length > 1) {
                        row.classList.add('cursor-pointer'); // Make row look clickable only if expandable
                        // Create SVG triangle
                        const svgIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svgIcon.setAttribute('viewBox', '0 0 10 10');
                        svgIcon.setAttribute('class', 'expander-svg-icon'); // For CSS rotation and potential styling
                        svgIcon.style.width = '10px';
                        svgIcon.style.height = '10px';
                        svgIcon.style.fill = '#888888'; // Medium gray
                        // Override for dark mode if needed (could also use CSS for this)
                        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                            svgIcon.style.fill = '#bbbbbb'; // Lighter gray for dark mode
                        }
                        
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', '2,1 8,5 2,9'); // Triangle points
                        
                        svgIcon.appendChild(polygon);
                        iconContainer.appendChild(svgIcon);
                        // Add to `row` so `expanded` class applies for rotation
                        row.appendChild(iconContainer); // Add to row, not cell, if class is on row.
                    }
                    
                    sequenceCell.appendChild(iconContainer); // Add icon container to cell
                    sequenceCell.appendChild(document.createTextNode(seq.sequenceString));
                    
                    row.insertCell().textContent = seq.data.name;
                    row.cells[1].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'dark:text-stone-300', 'table-cell-valign');
                    row.insertCell().textContent = seq.codepointsUPlus;
                    row.cells[2].classList.add('px-4', 'py-3', 'text-sm', 'text-stone-700', 'font-mono', 'dark:text-stone-300', 'table-cell-valign');

                    if (seq.individualCodepointsHex.length > 1) {
                        row.addEventListener('click', () => toggleEmojiComponentDetails(row, seq.individualCodepointsHex));
                    }
                });
            } else {
                emojiSequenceSectionElement.classList.add('hidden');
            }
        }

        function toggleEmojiComponentDetails(clickedRow, codepointHexArray) {
            clickedRow.classList.toggle('expanded');
            
            const svgIconElement = clickedRow.querySelector('.expander-svg-icon');
            if (svgIconElement) {
                 svgIconElement.style.transform = clickedRow.classList.contains('expanded') ? 'rotate(90deg)' : 'rotate(0deg)';
            }


            const potentialSubRow = clickedRow.nextElementSibling;
            const isExistingAndCorrectSubRow = potentialSubRow && potentialSubRow.classList.contains('emoji-details-sub-row');

            if (!clickedRow.classList.contains('expanded')) { // If we just removed 'expanded', it means we are collapsing
                if (isExistingAndCorrectSubRow) {
                    potentialSubRow.style.display = 'none'; 
                }
            } else { // We are expanding
                if (isExistingAndCorrectSubRow) {
                    potentialSubRow.style.display = ''; 
                } else {
                    const detailsRow = emojiSequenceBodyElement.insertRow(clickedRow.rowIndex); 
                    detailsRow.classList.add('emoji-details-sub-row');
                    const detailsCell = detailsRow.insertCell();
                    detailsCell.colSpan = clickedRow.cells.length; 
                    detailsCell.classList.add('sub-table-container', 'p-0', 'bg-sky-50', 'dark:bg-sky-950');

                    const subTable = document.createElement('table');
                    subTable.classList.add('min-w-full', 'divide-y', 'divide-stone-300', 'dark:divide-stone-600');
                    
                    const subThead = subTable.createTHead();
                    subThead.classList.add('bg-stone-50', 'dark:bg-stone-700'); 
                    const subHeaderRow = subThead.insertRow();
                    const headers = ["Char", "Codepoint (U+)", "Name", "UTF-8", "UTF-16", "UTF-16 LE"];
                    
                    headers.forEach((headerText, index) => {
                        const th = document.createElement('th');
                        th.scope = 'col';
                        th.classList.add('px-3', 'py-2', 'text-left', 'text-xs', 'font-medium', 'text-stone-500', 'uppercase', 'tracking-wider', 'dark:text-stone-400');
                        // Apply padding-left only to the first header cell
                        if (index === 0) {
                            th.classList.add('pl-10'); // w-8 in Tailwind = 2rem padding
                        }
                        th.textContent = headerText;
                        subHeaderRow.appendChild(th);
                    });

                    const subTbody = subTable.createTBody();
                    subTbody.classList.add('bg-sky-50', 'divide-y', 'divide-stone-200', 'dark:bg-sky-950', 'dark:divide-stone-700');

                    codepointHexArray.forEach(cpHex => {
                        const codepointInt = parseInt(cpHex, 16);
                        const char = String.fromCodePoint(codepointInt);
                        
                        const subRow = subTbody.insertRow();
                        let cellIdx = 0; 

                        subRow.insertCell(cellIdx++).textContent = char;
                        // Apply base padding and extra left padding to the first body cell
                        subRow.cells[0].classList.add('px-3', 'py-2', 'pl-10', 'text-base', 'font-mono', 'table-cell-valign');

                        subRow.insertCell(cellIdx++).textContent = formatCodepoint(codepointInt);
                        subRow.cells[1].classList.add('px-3', 'py-2', 'text-xs', 'font-mono', 'table-cell-valign');
                        
                        subRow.insertCell(cellIdx++).textContent = findCharacterName(codepointInt);
                        subRow.cells[2].classList.add('px-3', 'py-2', 'text-xs', 'table-cell-valign');
                        
                        subRow.insertCell(cellIdx++).textContent = getUtf8HexBytes(char);
                        subRow.cells[3].classList.add('px-3', 'py-2', 'text-xs', 'font-mono', 'whitespace-nowrap', 'table-cell-valign');
                        
                        subRow.insertCell(cellIdx++).textContent = getUtf16HexCodeUnits(char);
                        subRow.cells[4].classList.add('px-3', 'py-2', 'text-xs', 'font-mono', 'whitespace-nowrap', 'table-cell-valign');

                        subRow.insertCell(cellIdx++).textContent = getUtf16LEHexCodeUnits(char);
                        subRow.cells[5].classList.add('px-3', 'py-2', 'text-xs', 'font-mono', 'whitespace-nowrap', 'table-cell-valign');
                        
                        // Style all cells' text color
                        for(let k=0; k < cellIdx; k++) { 
                            subRow.cells[k].classList.add('text-stone-700', 'dark:text-stone-300');
                        }
                    });
                    detailsCell.appendChild(subTable);
                }
            }
        }

        function findBlockInfo(codepoint) { 
            for (const block of unicodeBlocks) {
                if (codepoint >= block.start && codepoint <= block.end) { return block; }
            }
            return null; 
        }
        function findBlockName(codepoint) { 
            const blockInfo = findBlockInfo(codepoint);
            return blockInfo ? blockInfo.name : 'N/A';
        }

        function findCharacterName(codepointInt) {
            const codepointHex = codepointInt.toString(16).toUpperCase().padStart(4, '0');
            if (unicodeCharacterNames[codepointHex]) {
                return unicodeCharacterNames[codepointHex];
            }
            for (const range of unicodeAlgorithmicNameRangesArray) {
                if (codepointInt >= range.start && codepointInt <= range.end) {
                    if (range.type === 'CJK' || range.type === 'HANGUL') {
                         return range.namePrefix + codepointHex;
                    } else { 
                         return range.namePrefix + codepointHex; 
                    }
                }
            }
            return 'N/A';
        }

        function formatCodepoint(codepointInt) {
            const hexString = codepointInt.toString(16).toUpperCase();
            if (codepointInt <= 0xFFFF) {
                return "U+" + hexString.padStart(4, '0');
            } else if (codepointInt <= 0xFFFFF) {
                return "U+" + hexString.padStart(5, '0');
            } else {
                return "U+" + hexString.padStart(6, '0');
            }
        }

        function getUtf8HexBytes(char) {
            return Array.from(utf8Encoder.encode(char)).map(byte => byte.toString(16).padStart(2, '0').toUpperCase()).join(' ');
        }

        function getUtf16HexCodeUnits(char) { 
            const codeUnits = [];
            for (let i = 0; i < char.length; i++) {
                codeUnits.push(char.charCodeAt(i).toString(16).padStart(4, '0').toUpperCase());
            }
            return codeUnits.join(' ');
        }

        function getUtf16LEHexCodeUnits(char) {
            const codeUnits = [];
            for (let i = 0; i < char.length; i++) {
                const codeUnit = char.charCodeAt(i);
                const byte1 = (codeUnit & 0xFF).toString(16).padStart(2, '0').toUpperCase();
                const byte2 = ((codeUnit >> 8) & 0xFF).toString(16).padStart(2, '0').toUpperCase();
                codeUnits.push(byte1 + byte2);
            }
            return codeUnits.join(' ');
        }

    </script>
</body>
</html>